theory Chapter4
imports "~~/src/HOL/IMP/ASM"
begin

inductive star :: "('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool"  for r where
refl:  "star r x x" |
step:  "r x y \<Longrightarrow> star r y z \<Longrightarrow> star r x z"

text{*
\section*{Chapter 4}

\exercise
Formalize the following definition of palindromes
\begin{itemize}
\item The empty list and a singleton list are palindromes.
\item If @{text xs} is a palindrome, so is @{term "a # xs @ [a]"}.
\end{itemize}
as an inductive predicate
*}

inductive palindrome :: "'a list \<Rightarrow> bool" where
palindromeE: "palindrome []" |
palindromeSS: "palindrome xs \<Longrightarrow> palindrome (x # xs @ [x])"

text {* and prove *}

lemma "palindrome xs \<Longrightarrow> rev xs = xs"
apply (induction rule: palindrome.induct)
  apply(simp)
  apply(simp)
done

text{*
\exercise
In Chapter 3 we defined a recursive evaluation function
@{text "aval ::"} @{typ "aexp \<Rightarrow> state \<Rightarrow> val"}.
Define an inductive evaluation predicate and prove that it agrees with
the recursive function:
*}

inductive aval_rel :: "aexp \<Rightarrow> state \<Rightarrow> val \<Rightarrow> bool" where
  n: "aval_rel (N n) s n" |
  v: "aval_rel (V v) s (s v)" |
  p: "\<lbrakk>aval_rel a\<^sub>1 s v\<^sub>1; aval_rel a\<^sub>2 s v\<^sub>2\<rbrakk> \<Longrightarrow> aval_rel (Plus a\<^sub>1 a\<^sub>2) s (v\<^sub>1 + v\<^sub>2)"

lemma aval_rel_aval: "aval_rel a s v \<Longrightarrow> aval a s = v"
  apply (induction rule:"aval_rel.induct")
  apply simp
  apply simp
  apply simp
done

lemma aval_aval_rel: "aval a s = v \<Longrightarrow> aval_rel a s v"
  apply (induction a arbitrary: s v)
  apply auto
  apply (rule aval_rel.n)
  apply (rule aval_rel.v)
  apply (rule aval_rel.p)
  apply auto
done

corollary "aval_rel a s v \<longleftrightarrow> aval a s = v"
  apply auto
  apply (rule aval_rel_aval)
  apply simp
  apply (rule aval_aval_rel)
  apply simp
done

text{*
\endexercise

\exercise
Consider the stack machine from Chapter~3
and recall the concept of \concept{stack underflow}
from Exercise~\ref{exe:stack-underflow}.
Define an inductive predicate
*}

inductive ok :: "nat \<Rightarrow> instr list \<Rightarrow> nat \<Rightarrow> bool" where
(* your definition/proof here *)

text{*
such that @{text "ok n is n'"} means that with any initial stack of length
@{text n} the instructions @{text "is"} can be executed
without stack underflow and that the final stack has length @{text n'}.

Using the introduction rules for @{const ok},
prove the following special cases: *}

lemma "ok 0 [LOAD x] (Suc 0)"
(* your definition/proof here *)

lemma "ok 0 [LOAD x, LOADI v, ADD] (Suc 0)"
(* your definition/proof here *)

lemma "ok (Suc (Suc 0)) [LOAD x, ADD, ADD, LOAD y] (Suc (Suc 0))"
(* your definition/proof here *)

text {* Prove that @{text ok} correctly computes the final stack size: *}

lemma "\<lbrakk>ok n is n'; length stk = n\<rbrakk> \<Longrightarrow> length (exec is s stk) = n'"
(* your definition/proof here *)

text {*
Prove that instruction sequences generated by @{text comp}
cannot cause stack underflow: \ @{text "ok n (comp a) ?"} \ for
some suitable value of @{text "?"}.
\endexercise
*}


end

